import Velvet.Std

-- [Adding this for AI-generated proof]
import Mathlib.Tactic.NormNum


set_option loom.semantics.termination "partial"
set_option loom.semantics.choice "demonic"

@[reducible]
def addr := ℤ

@[reducible]
def path (h : addr → addr) (x : addr) (l : List addr) (y : addr) :=
  match l with
  | [] => x = y
  | a :: t => a ≠ 0 ∧ x = a ∧ path h (h a) t y

@[reducible]
def distinct (l : List addr) :=
  match l with
  | [] => ⊤
  | a :: t => (∀ x, x ∈ t → x ≠ a) ∧ distinct t

@[reducible]
def distPath (h : addr → addr) (x : addr) (l : List addr) (y : addr) :=
  path h x l y ∧ distinct l

-----------------------------------------------------------------------------------
--- The program
-----------------------------------------------------------------------------------

method mem_alloc
  (saddr : addr → addr) (block_size : addr → ℕ) (mut next : addr → addr)
  (mut free_list : addr) (size : ℕ)
  (Ps : List addr)
return (mem : addr)
  require distPath next free_list Ps 0
  ensures ∀ b, List.find? (fun x => block_size x ≥ size) Ps = some b →
          mem = b ∧ distPath next free_list (List.erase Ps b) 0
do
  if free_list = 0 then
    return 0
  else
    if block_size free_list ≥ size then
      let res := free_list
      free_list := next free_list
      return res
    else
      let mut q := free_list
      let mut p := next free_list
      while p ≠ 0 ∧ block_size p < size
      invariant distPath next free_list Ps 0
      invariant ∃ Qs, distPath next free_list Qs p ∧ ∀ a, a ∈ Qs → block_size a < size
      invariant p = next q
      invariant ∃ Qs, distPath next free_list Qs q
      invariant q ≠ 0
      do
        q := p
        p := next p
      if p ≠ 0 then
        next := Function.update next q (next p)
        return p
      else
        return 0


----------------------------------------------------------------------------------------
-- [Generated by Aristotle] HELPER LEMMAS
----------------------------------------------------------------------------------------

/-
Concatenating two paths yields a path from the start of the first to the end of the second.
-/
lemma path_append {h : addr → addr} {x y z : addr} {l1 l2 : List addr} :
  path h x l1 y → path h y l2 z → path h x (l1 ++ l2) z := by
    induction l1 generalizing x y z <;> aesop

lemma path_append' {h : addr → addr} {x y : addr} {l1 l2 : List addr} :
  path h x (l1 ++ l2) y ↔ ∃ z, path h x l1 z ∧ path h z l2 y := by
    induction l1 generalizing x <;> aesop;

lemma path_prefix {h : addr → addr} {x y1 y2 : addr} {l1 l2 : List addr}
  (h1 : path h x l1 y1) (h2 : path h x l2 y2) : l1 <+: l2 ∨ l2 <+: l1 := by
    -- By definition of path, if there's a path from x to y1 and another from x to y2, then either the path to y1 is a prefix of the path to y2 or vice versa.
    apply Classical.byContradiction
    intro h_not_prefix_or_suffix;
    -- By definition of path, if there's a path from x to y1 and another from x to y2, then either the path to y1 is a prefix of the path to y2 or vice versa. This is a fundamental property of paths.
    have h_prefix_or_suffix : ∀ x y1 y2 l1 l2, path h x l1 y1 → path h x l2 y2 → (l1 <+: l2 ∨ l2 <+: l1) := by
      intros x y1 y2 l1 l2 h1 h2;
      induction l1 generalizing x l2 <;> induction l2 generalizing y1 y2 <;> aesop;
    exact h_not_prefix_or_suffix <| h_prefix_or_suffix x y1 y2 l1 l2 h1 h2


lemma path_function {h : addr → addr} {x y1 y2 : addr} {l : List addr}
  (h1 : path h x l y1) (h2 : path h x l y2) : y1 = y2 := by
    -- By definition of path, if a path leads to two different addresses, those addresses must be the same.
    have h_unique : ∀ {h : addr → addr} {x y1 y2 : addr} {l : List addr}, path h x l y1 → path h x l y2 → y1 = y2 := by
      intro h x y1 y2 l h1 h2; induction l generalizing x y1 y2 <;> aesop;
    exact h_unique h1 h2

lemma path_zero_mem {h : addr → addr} {x y : addr} {l : List addr}
  (hp : path h x l y) : 0 ∉ l := by
    induction l <;> aesop;
    -- Since 0 is in the tail, the path from h x to y must include 0, which contradicts the definition of path.
    have h_contra : ∀ {l : List addr} {x y : addr}, 0 ∈ l → path h x l y → False := by
      intros l x y hl hp; induction l generalizing x y <;> aesop;
    exact h_contra a right

lemma path_nonzero {h : addr → addr} {x y : addr} {l : List addr}
  (hp : path h x l y) : ∀ a ∈ l, a ≠ 0 := by
    -- Apply the lemma that states if there's a path from x to y through l, then 0 cannot be in l.
    have := path_zero_mem hp; aesop

lemma distinct_append {l1 l2 : List addr} :
  distinct (l1 ++ l2) ↔ distinct l1 ∧ distinct l2 ∧ ∀ x ∈ l1, x ∉ l2 := by
    induction l1 <;> aesop

lemma distinct_path_no_cycle {h : addr → addr} {x : addr} {Ps Qs : List addr} {p : addr}
  (hPs : path h x Ps 0) (h_dist : distinct Ps) (hQs : path h x Qs p) (h_prefix : Qs <+: Ps) (hp : p ≠ 0) : p ∉ Qs := by
    -- If p were in Qs, then by the path condition, p would have to be 0, which contradicts hp.
    by_contra hp_in_Qs
    have h_path_zero : path h x Qs 0 := by
      cases h_prefix ; aesop;
      -- Since $Qs$ is a prefix of $Qs ++ w$, we can apply the path condition to get that $path h x Qs 0$.
      have h_path_Qs : path h x Qs p ∧ path h p w 0 := by
        rw [path_append'] at hPs; aesop;
        have := path_function hQs left; aesop;
      cases w <;> aesop;
      have := h_dist; simp_all +decide [ distinct_append ] ;
      grind +ring;
    exact hp ( by have := path_function hQs h_path_zero; aesop )

lemma path_update_of_not_mem {h : addr → addr} {x y u v : addr} {l : List addr}
  (hp : path h x l y) (hu : u ∉ l) : path (Function.update h u v) x l y := by
    induction l generalizing x y <;> aesop;
    -- Since $h x \neq u$, the update $h u v$ does not affect $h x$, so the path remains the same.
    have h_eq : Function.update h u v x = h x := by
      rw [ Function.update_of_ne ( Ne.symm left_1 ) ];
    grind

lemma path_split_at_p {h : addr → addr} {x p : addr} {Ps Qs : List addr}
  (hPs : path h x Ps 0) (hQs : path h x Qs p) (hp : p ≠ 0) : ∃ Rest, Ps = Qs ++ p :: Rest := by
    -- By the prefix property, since Qs is a prefix of Ps and p is not zero, we can split Ps into Qs and the rest.
    have h_prefix : Qs <+: Ps := by
      -- By the properties of paths, since both paths start at x, one must be a prefix of the other.
      have h_prefix : Qs <+: Ps ∨ Ps <+: Qs := by
        exact?;
      cases h_prefix <;> aesop;
      cases h_1 ; aesop;
      cases w <;> simp_all +decide [ path_append' ];
      aesop;
      exact absurd ( path_function left hPs ) ( by aesop );
    cases h_prefix ; aesop;
    -- By definition of `path`, if `path h x (Qs ++ w) 0`, then `path h x Qs p` and `path h p w 0`.
    have h_path_split : path h x Qs p ∧ path h p w 0 := by
      have := path_append'.mp hPs; aesop;
      have := path_function hQs left; aesop;
    cases w <;> aesop

lemma find_in_split {α} {p : α → Bool} {l1 l2 : List α} {b : α}
  (h1 : ∀ x ∈ l1, ¬ p x) (h2 : p b) : (l1 ++ b :: l2).find? p = some b := by
    induction l1 <;> aesop

lemma path_update_skip {h : addr → addr} {x p q : addr} {Qs_q Rest : List addr}
  (h_path : path h x (Qs_q ++ [q] ++ p :: Rest) 0)
  (h_distinct : distinct (Qs_q ++ [q] ++ p :: Rest))
  (h_link : p = h q)
  (hq : q ≠ 0) :
  path (Function.update h q (h p)) x (Qs_q ++ [q] ++ Rest) 0 := by
    simp +zetaDelta at *;
    rw [ path_append' ] at h_path ; aesop;
    rw [ distinct_append ] at h_distinct ; aesop;
    -- Since $h w \notin Qs_q$, we can apply the lemma `path_update_of_not_mem` to conclude the proof.
    apply path_append'.mpr;
    use w;
    aesop;
    · convert path_update_of_not_mem left _ using 1
      generalize_proofs at *;
      exact fun h => right_1 _ h |>.1 rfl;
    · exact?

lemma erase_middle_unique {l1 l2 : List addr} {p : addr}
  (h : distinct (l1 ++ p :: l2)) : (l1 ++ p :: l2).erase p = l1 ++ l2 := by
    rw [ List.erase_append_right ];
    · simp +decide [ List.erase_cons ];
    · induction l1 <;> aesop

/-
If `l1` is a path from `x` to `y` and `l2` is a path from `x` to `0`, and `y ≠ 0`, then `l2` must start with `l1` followed by `y`.
-/
lemma path_prefix_of_path_to_zero {h : addr → addr} {x y : addr} {l1 l2 : List addr} :
  path h x l1 y → path h x l2 0 → y ≠ 0 → ∃ t, l2 = l1 ++ y :: t := by
    induction l1 generalizing x l2 <;> induction l2 generalizing x <;> aesop

/-
If `l1 ++ a :: l2` is distinct, then `l1 ++ [a]` is distinct.
-/
lemma distinct_prefix {l1 l2 : List addr} {a : addr} : distinct (l1 ++ a :: l2) → distinct (l1 ++ [a]) := by
  induction l1 <;> aesop

-----------------------------------------------------------------------------------
-- Extracted Goals
-----------------------------------------------------------------------------------

lemma goal1: forall
       (saddr : addr → addr)
       (block_size : addr → ℕ)
       (nextOld : addr → addr)
       (free_listOld : addr)
       (size : ℕ)
       (Ps : List addr)
       (a : path nextOld free_listOld Ps 0)
       (a_1 : distinct Ps)
       (if_pos : free_listOld = 0)
      (b : addr),
  List.find? (fun x ↦ decide (block_size x ≥ size)) Ps = some b → 0 = b ∧ distPath nextOld free_listOld (Ps.erase b) 0 :=
  by
    -- [Generated by Aristotle]
    aesop;
    · induction Ps <;> aesop;
    · cases Ps <;> aesop;
    · -- Since Ps is distinct, removing any element from Ps will still result in a distinct list.
      have h_distinct_erase : ∀ {l : List addr}, distinct l → ∀ x ∈ l, distinct (l.erase x) := by
        intros l hl x hx; induction l <;> aesop;
        rw [ List.erase_cons ] ; aesop;
      exact h_distinct_erase a_1 b ( List.mem_of_find?_eq_some a_2 )

lemma goal2:
forall
(saddr : addr → addr)
(block_size : addr → ℕ)
(nextOld : addr → addr)
(free_listOld : addr)
(size : ℕ)
(Ps : List addr)
(a : path nextOld free_listOld Ps 0)
(a_1 : distinct Ps)
(if_neg : ¬free_listOld = 0)
(if_pos : block_size free_listOld ≥ size)
(b : addr),
  List.find? (fun x ↦ decide (block_size x ≥ size)) Ps = some b →
    free_listOld = b ∧ distPath nextOld (nextOld free_listOld) (Ps.erase b) 0 :=
  by
    -- [Generated by Aristotle]
    intros saddr block_size nextOld free_listOld size Ps hpath hd hfree_listOld hblock_size b hb
    have hfb : free_listOld = b := by
      induction Ps <;> aesop;
    cases Ps <;> aesop

lemma goal3:
forall
(saddr : addr → addr)
(block_size : addr → ℕ)
(nextOld : addr → addr)
(free_listOld : addr)
(size : ℕ)
(Ps : List addr)
(a : path nextOld free_listOld Ps 0)
(a_1 : distinct Ps)
(if_neg : ¬free_listOld = 0)
(if_neg_1 : ¬block_size free_listOld ≥ size)
(p q : addr)
(a_2 : path nextOld free_listOld Ps 0)
(a_3 : distinct Ps)
(invariant_2 : ∃ Qs, distPath nextOld free_listOld Qs p ∧ ∀ a ∈ Qs, block_size a < size)
(invariant_3 : p = nextOld q)
(invariant_4 : ∃ Qs, distPath nextOld free_listOld Qs q)
(invariant_5 : q ≠ 0)
(a_4 : p ≠ 0)
(a_5 : block_size p < size),
∃ Qs, distPath nextOld free_listOld Qs (nextOld p) ∧ ∀ a ∈ Qs, block_size a < size :=
  by
    -- [Generated by Aristotle]
    norm_num +zetaDelta at *; -- [Ilya] WTF is this, needs a new import
    intro block_size nextOld free_listOld size Ps hPs hPs' hfree hsize p q hPs'' hPs''' x hx hx' hx'' hp q' hq hq' hq'' hp';
    have := path_prefix_of_path_to_zero hx hPs''; aesop;
    refine' ⟨ x ++ [ nextOld q ], _, _ ⟩ <;> simp_all +decide [ distPath ];
    · aesop;
      · convert path_append hx ( show path nextOld ( nextOld q ) [ nextOld q ] ( nextOld ( nextOld q ) ) from ?_ ) using 1;
        exact ⟨ hp', rfl, rfl ⟩;
      · exact?;
    · rintro a ( ha | rfl ) <;> [ exact hx'' a ha; exact a_5 ]


lemma goal4 :
forall
(saddr : addr → addr)
(block_size : addr → ℕ)
(nextOld : addr → addr)
(free_listOld : addr)
(size : ℕ)
(Ps : List addr)
(a : path nextOld free_listOld Ps 0)
(a_1 : distinct Ps)
(if_neg : ¬free_listOld = 0)
(if_neg_1 : ¬block_size free_listOld ≥ size),
∃ Qs, distPath nextOld free_listOld Qs (nextOld free_listOld) ∧ ∀ a ∈ Qs, block_size a < size := by
    -- [Generated by Aristotle]
    aesop?;
    -- Let's choose Qs to be the list [free_listOld].
    use [free_listOld];
    aesop


lemma goal5
(saddr : addr → addr)
(block_size : addr → ℕ)
(nextOld : addr → addr)
(free_listOld : addr)
(size : ℕ)
(Ps : List addr)
(a : path nextOld free_listOld Ps 0)
(a_1 : distinct Ps)
(if_neg : ¬free_listOld = 0)
(if_neg_1 : ¬block_size free_listOld ≥ size)
: ∃ Qs, distPath nextOld free_listOld Qs free_listOld :=
  by
    -- [Generated by Aristotle]
    -- The empty list is a valid path from free_listOld to free_listOld and is distinct.
    use []
    simp [distPath]


lemma goal6
: forall (saddr : addr → addr)
(block_size : addr → ℕ)
(nextOld : addr → addr)
(free_listOld : addr)
(size : ℕ)
(Ps : List addr)
(a : path nextOld free_listOld Ps 0)
(a_1 : distinct Ps)
(if_neg : ¬free_listOld = 0)
(if_neg_1 : ¬block_size free_listOld ≥ size)
(p q : addr)
(a_2 : path nextOld free_listOld Ps 0)
(a_3 : distinct Ps)
(invariant_2 : ∃ Qs, distPath nextOld free_listOld Qs p ∧ ∀ a ∈ Qs, block_size a < size)
(invariant_3 : p = nextOld q)
(invariant_4 : ∃ Qs, distPath nextOld free_listOld Qs q)
(invariant_5 : q ≠ 0)
(done_1 : ¬(p ≠ 0 ∧ block_size p < size))
(i q_1 : addr)
(i_1 : p = i ∧ q = q_1)
(if_pos : i ≠ 0)
(b : addr),
  List.find? (fun x ↦ decide (block_size x ≥ size)) Ps = some b →
    i = b ∧ distPath (Function.update nextOld q_1 (nextOld i)) free_listOld (Ps.erase b) 0 := by
  intro saddr block_size nextOld free_listOld size Ps a a_1
  intro if_neg  if_neg_1 p q a_2 a_3
  intro invariant_2 invariant_3 invariant_4 invariant_5 done_1
  intro i q_1 i_1 if_pos b
  intro H
  have := List.mem_of_find?_eq_some H; aesop;
  · have := path_prefix left_2 a_2; aesop;
    · cases h ; aesop;
      · grind;
      · grind +ring;
      · grind +ring;
      · have := path_split_at_p a_2 left_2 if_pos; aesop;
    · grind;
  · -- Since `p` is found in `Ps`, we have `p = b`.
    have hp_eq_b : nextOld q = b := by
      have := path_prefix left_2 a_2; aesop;
      · cases h ; aesop;
        · grind;
        · grind +ring;
        · grind +ring;
        · have := path_split_at_p a_2 left_2 if_pos; aesop;
      · grind;
    have h_path_split : ∃ Rest, Ps = w ++ [q] ++ nextOld q :: Rest := by
      have h_path_split : ∃ Rest, Ps = w ++ [q] ++ nextOld q :: Rest := by
        have h_path_split : path nextOld free_listOld Ps 0 ∧ path nextOld free_listOld (w ++ [q]) (nextOld q) := by
          aesop;
          exact path_append'.mpr ⟨ q, left_1, by tauto ⟩
        apply path_split_at_p; exact h_path_split.left; exact h_path_split.right; exact if_pos
      generalize_proofs at *;
      exact h_path_split;
    have h_erase : List.erase Ps b = w ++ [q] ++ List.erase (nextOld q :: h_path_split.choose) b := by
      have h_erase : List.erase (w ++ [q] ++ nextOld q :: h_path_split.choose) b = w ++ [q] ++ List.erase (nextOld q :: h_path_split.choose) b := by
        have h_distinct : distinct (w ++ [q] ++ nextOld q :: h_path_split.choose) := by
          rw [ ← h_path_split.choose_spec ] ; assumption
        have h_erase_middle_unique : ∀ {l1 l2 : List addr} {p : addr}, distinct (l1 ++ p :: l2) → List.erase (l1 ++ p :: l2) p = l1 ++ l2 := by
          exact?;
        grind;
      rw [ ← h_erase, ← h_path_split.choose_spec ];
    have h_path_update : path (Function.update nextOld q (nextOld (nextOld q))) free_listOld (w ++ [q] ++ h_path_split.choose) 0 := by
      have h_path_update : path nextOld free_listOld (w ++ [q] ++ nextOld q :: h_path_split.choose) 0 := by
        convert a_2 using 1;
        exact h_path_split.choose_spec.symm;
      convert path_update_skip h_path_update _ _ _ using 1;
      · convert a_3 using 1;
        exact h_path_split.choose_spec.symm;
      · rfl;
      · assumption;
    aesop;
  · -- Since `Ps` is distinct and `b` is in `Ps`, `Ps.erase b` is also distinct.
    have h_erase_distinct : ∀ (l : List addr), distinct l → ∀ (x : addr), x ∈ l → distinct (l.erase x) := by
      intros l hl x hx; induction l <;> aesop;
      rw [ List.erase_cons ] ; aesop;
    exact h_erase_distinct _ a_3 _ this


/- [Generated by Aristotle]
If there are two paths from `x` to `0` using the same next pointer function `h`, then the lists of addresses must be identical.
-/
lemma path_zero_unique (h : addr → addr) (x : addr) (l1 l2 : List addr) :
  path h x l1 0 → path h x l2 0 → l1 = l2 := by
    induction l1 generalizing x l2 <;> induction l2 <;> aesop ( simp_config := { singlePass := true } ) ;


lemma goal7
(saddr : addr → addr)
(block_size : addr → ℕ)
(nextOld : addr → addr)
(free_listOld : addr)
(size : ℕ)
(Ps : List addr)
(a : path nextOld free_listOld Ps 0)
(a_1 : distinct Ps)
(if_neg : ¬free_listOld = 0)
(if_neg_1 : ¬block_size free_listOld ≥ size)
(p q : addr)
(a_2 : path nextOld free_listOld Ps 0)
(a_3 : distinct Ps)
(invariant_2 : ∃ Qs, distPath nextOld free_listOld Qs p ∧ ∀ a ∈ Qs, block_size a < size)
(invariant_3 : p = nextOld q)
(invariant_4 : ∃ Qs, distPath nextOld free_listOld Qs q)
(invariant_5 : q ≠ 0)
(done_1 : ¬(p ≠ 0 ∧ block_size p < size))
(i q_1 : addr)
(i_1 : p = i ∧ q = q_1)
(if_neg_2 : ¬i ≠ 0)
: ∀ (b : addr),
  List.find? (fun x ↦ decide (block_size x ≥ size)) Ps = some b → 0 = b ∧ distPath nextOld free_listOld (Ps.erase b) 0 :=
  by
    -- [Generated by Aristotle]
    have h_contradiction : ∀ a ∈ Ps, block_size a < size := by
      obtain ⟨ Qs, hQs₁, hQs₂ ⟩ := invariant_2; have := path_zero_unique nextOld free_listOld Qs Ps; aesop;
    grind

-----------------------------------------------------------------------------------
-- The actual verification
-----------------------------------------------------------------------------------

prove_correct mem_alloc by
  -- loom_goals_intro
  -- loom_unfold
  loom_solve
  apply goal1 <;> assumption
  apply goal2 <;> assumption
  apply goal3 <;> assumption
  apply goal4 <;> assumption
  apply goal5 <;> assumption
  {
    apply goal6 <;> try assumption
    cases i_1 ; trivial
  }
  {
    apply goal7 <;> try assumption
    cases i_1 ; trivial
  }
