/-
This file was edited by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 34055cff-935b-4248-8e11-63a4f6ae3930

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

The following was proved by Aristotle:

- theorem precondition_equiv (nums : List Int):
  VerinaSpec.maxStrength_precond nums ↔ LeetProofSpec.precondition nums

- theorem postcondition_equiv (nums : List Int) (result : Int) (h_precond : VerinaSpec.maxStrength_precond nums):
  VerinaSpec.maxStrength_postcond nums result h_precond ↔ LeetProofSpec.postcondition nums result
-/

import Lean
import Mathlib.Tactic
import Mathlib


namespace VerinaSpec

@[reducible]
def maxStrength_precond (nums : List Int) : Prop :=
  -- !benchmark @start precond
  nums ≠ []

-- !benchmark @end precond

@[reducible]
def maxStrength_postcond (nums : List Int) (result: Int) (h_precond : maxStrength_precond (nums)) : Prop :=
  -- !benchmark @start postcond
  let sublists := nums.sublists.filter (· ≠ [])
  let products := sublists.map (List.foldl (· * ·) 1)
  products.contains result ∧ products.all (· ≤ result)

-- !benchmark @end postcond

end VerinaSpec

namespace LeetProofSpec

-- Helper function to compute product of selected elements based on a selector
-- selector i = true means element at index i is selected
def selectedProduct (nums : List Int) (selector : Nat → Bool) : Int :=
  (List.range nums.length).foldl 
    (fun acc i => if selector i then acc * nums[i]! else acc) 
    1

-- A selection is non-empty if at least one index is selected
def isNonEmptySelection (nums : List Int) (selector : Nat → Bool) : Prop :=
  ∃ i : Nat, i < nums.length ∧ selector i = true

-- Property: result is achievable (equals the product of some non-empty subset)
def isAchievable (nums : List Int) (result : Int) : Prop :=
  ∃ selector : Nat → Bool, 
    isNonEmptySelection nums selector ∧ 
    selectedProduct nums selector = result

-- Property: result is maximal (greater than or equal to all non-empty subset products)
def isMaximal (nums : List Int) (result : Int) : Prop :=
  ∀ selector : Nat → Bool, 
    isNonEmptySelection nums selector → 
    selectedProduct nums selector ≤ result

-- Precondition: the list must be non-empty
def precondition (nums : List Int) : Prop :=
  nums.length > 0

-- Postcondition: result is the maximum product of any non-empty subset
def postcondition (nums : List Int) (result : Int) : Prop :=
  isAchievable nums result ∧ isMaximal nums result

end LeetProofSpec

-- Equivalence theorems

theorem precondition_equiv (nums : List Int):
  VerinaSpec.maxStrength_precond nums ↔ LeetProofSpec.precondition nums := by
  -- The preconditions are equivalent because a list is non-empty if and only if its length is greater than zero.
  simp [VerinaSpec.maxStrength_precond, LeetProofSpec.precondition];
  cases nums <;> aesop

noncomputable section AristotleLemmas

/-
Helper function to convert a selector to the corresponding sublist.
-/
def sublistFromSelector (nums : List Int) (selector : Nat → Bool) : List Int :=
  ((List.range nums.length).filter selector).map (fun i => nums[i]!)

/-
The selectedProduct function is equivalent to folding multiplication over the sublist generated by the selector.
-/
theorem selectedProduct_eq_prod (nums : List Int) (selector : Nat → Bool) :
  LeetProofSpec.selectedProduct nums selector = (sublistFromSelector nums selector).foldl (· * ·) 1 := by
    unfold LeetProofSpec.selectedProduct sublistFromSelector;
    induction List.range nums.length using List.reverseRecOn <;> aesop

/-
The list generated by sublistFromSelector is always a sublist of the original list.
-/
theorem sublistFromSelector_mem_sublists (nums : List Int) (selector : Nat → Bool) :
  sublistFromSelector nums selector ∈ nums.sublists := by
    convert List.mem_sublists.mpr _;
    convert List.Sublist.map _ _;
    rotate_left;
    exact List.range nums.length;
    · exact?;
    · refine' List.ext_get _ _ <;> aesop

/-
For every sublist in the list of sublists, there exists a selector that generates it.
-/
theorem exists_selector_of_sublist (nums : List Int) (sub : List Int) (h : sub ∈ nums.sublists) :
  ∃ selector : Nat → Bool, sublistFromSelector nums selector = sub := by
    norm_num +zetaDelta at *;
    -- By definition of `sublistFromSelector`, if `sub` is a sublist of `nums`, then there exists a selector `selector` such that `sub = sublistFromSelector nums selector`.
    have h_sublistToSelector : ∀ {L₁ L₂ : List ℤ}, L₁.Sublist L₂ → ∃ (selector : Nat → Bool), L₁ = sublistFromSelector L₂ selector := by
      intro L₁ L₂ h_sublist
      induction' h_sublist with L₁ L₂ h_sublist ih;
      · exists fun _ => Bool.false;
      · obtain ⟨ selector, rfl ⟩ := ‹_›;
        refine' ⟨ fun i => if i = 0 then Bool.false else selector ( i - 1 ), _ ⟩ ; simp +decide [ sublistFromSelector ];
        simp +decide [ List.range_succ_eq_map, List.filter_map ];
        refine' List.ext_get _ _ <;> aesop;
      · simp_all +decide [ sublistFromSelector ];
        rename_i k hk ih; rcases ih with ⟨ selector, ih ⟩ ; use fun i => if i = 0 then Bool.true else selector ( i - 1 ) ; simp_all +decide [ List.range_succ_eq_map ] ;
        rw [ List.filter_map ] ; aesop;
    simpa only [ eq_comm ] using h_sublistToSelector h

/-
A selection is non-empty if and only if the generated sublist is non-empty.
-/
theorem isNonEmptySelection_iff_sublist_nonEmpty (nums : List Int) (selector : Nat → Bool) :
  LeetProofSpec.isNonEmptySelection nums selector ↔ sublistFromSelector nums selector ≠ [] := by
    unfold LeetProofSpec.isNonEmptySelection sublistFromSelector; aesop;

end AristotleLemmas

theorem postcondition_equiv (nums : List Int) (result : Int) (h_precond : VerinaSpec.maxStrength_precond nums):
  VerinaSpec.maxStrength_postcond nums result h_precond ↔ LeetProofSpec.postcondition nums result := by
  constructor <;> intro h;
  · -- By definition of `isNonEmptySelection`, there exists a selector that generates a non-empty sublist whose product is `result`.
    obtain ⟨selector, hselector⟩ : ∃ selector : Nat → Bool, sublistFromSelector nums selector ≠ [] ∧ (sublistFromSelector nums selector).foldl (· * ·) 1 = result := by
      -- By definition of `maxStrength_postcond`, there exists a non-empty sublist whose product is `result`.
      obtain ⟨sub, hsub⟩ : ∃ sub ∈ nums.sublists.filter (· ≠ []), (sub.foldl (· * ·) 1) = result := by
        grind;
      obtain ⟨selector, hselector⟩ : ∃ selector : Nat → Bool, sublistFromSelector nums selector = sub := by
        apply exists_selector_of_sublist;
        exact List.mem_of_mem_filter hsub.1;
      aesop;
    refine' ⟨ ⟨ selector, _, _ ⟩, _ ⟩;
    · exact isNonEmptySelection_iff_sublist_nonEmpty _ _ |>.2 hselector.1;
    · rw [ ← hselector.2, selectedProduct_eq_prod ];
    · intro selector' hselector'
      obtain ⟨sub, hsub⟩ : ∃ sub : List Int, sub ∈ nums.sublists ∧ sub ≠ [] ∧ (sub.foldl (· * ·) 1) = (sublistFromSelector nums selector').foldl (· * ·) 1 := by
        use sublistFromSelector nums selector';
        exact ⟨ sublistFromSelector_mem_sublists nums selector', by simpa using isNonEmptySelection_iff_sublist_nonEmpty nums selector' |>.1 hselector' ⟩;
      have := h.2;
      simp_all +decide [ List.all_eq ];
      convert this _ _ hsub.1 hsub.2.1 rfl using 1;
      rw [ hsub.2.2, selectedProduct_eq_prod ];
  · constructor;
    · obtain ⟨ selector, h₁, h₂ ⟩ := h.1;
      have h_sublist : sublistFromSelector nums selector ∈ nums.sublists.filter (· ≠ []) := by
        rw [ List.mem_filter ];
        exact ⟨ sublistFromSelector_mem_sublists nums selector, by rw [ decide_eq_true_iff ] ; exact isNonEmptySelection_iff_sublist_nonEmpty nums selector |>.1 h₁ ⟩;
      have h_sublist_prod : (sublistFromSelector nums selector).foldl (· * ·) 1 = result := by
        rw [ ← h₂, selectedProduct_eq_prod ];
      grind;
    · simp +zetaDelta at *;
      intro x hxlist
      obtain ⟨selector, h_selector⟩ : ∃ selector : Nat → Bool, sublistFromSelector nums selector = x := by
        apply exists_selector_of_sublist;
        exact?;
      by_cases h_empty : sublistFromSelector nums selector = [];
      · aesop;
      · exact Or.inr ( by simpa only [ ← h_selector, selectedProduct_eq_prod ] using h.2 selector ( by simpa [ isNonEmptySelection_iff_sublist_nonEmpty ] using h_empty ) )