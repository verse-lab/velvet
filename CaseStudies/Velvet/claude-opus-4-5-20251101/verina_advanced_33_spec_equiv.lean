/-
This file was edited by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d232ba18-2332-404d-a9f6-9e0f2bffcb90

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

The following was proved by Aristotle:

- theorem precondition_equiv (nums : List Int):
  VerinaSpec.longestIncreasingSubsequence_precond nums ↔ LeetProofSpec.precondition nums

- theorem postcondition_equiv (nums : List Int) (result : Nat) (h_precond : VerinaSpec.longestIncreasingSubsequence_precond nums):
  VerinaSpec.longestIncreasingSubsequence_postcond nums result h_precond ↔ LeetProofSpec.postcondition nums result
-/

import Lean
import Mathlib.Tactic
import Mathlib.Data.List.Basic


namespace VerinaSpec

def longestIncreasingSubsequence_precond (nums : List Int) : Prop :=
  -- !benchmark @start precond
  True

-- !benchmark @end precond

def longestIncreasingSubsequence_postcond (nums : List Int) (result: Nat) (h_precond : longestIncreasingSubsequence_precond (nums)) : Prop :=
  -- !benchmark @start postcond
  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse
  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)
  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)

-- !benchmark @end postcond

end VerinaSpec

namespace LeetProofSpec

-- Helper: Check if a list is strictly increasing (non-recursive, using quantifiers)
def isStrictlyIncreasing (l : List Int) : Prop :=
  ∀ i j, i < j → j < l.length → l[i]! < l[j]!

-- Helper: The result is the maximum length among all strictly increasing subsequences
-- Uses List.Sublist from Mathlib to define subsequence relationship
def isLongestIncreasingSubsequenceLength (nums : List Int) (len : Nat) : Prop :=
  -- There exists a strictly increasing subsequence of this length
  (∃ subseq : List Int, subseq.Sublist nums ∧ isStrictlyIncreasing subseq ∧ subseq.length = len) ∧
  -- No strictly increasing subsequence has greater length
  (∀ subseq : List Int, subseq.Sublist nums → isStrictlyIncreasing subseq → subseq.length ≤ len)

def precondition (nums : List Int) : Prop :=
  True

-- no preconditions

def postcondition (nums : List Int) (result : Nat) : Prop :=
  -- For empty list, result is 0
  (nums = [] → result = 0) ∧
  -- For non-empty list, result is the length of longest strictly increasing subsequence
  (nums ≠ [] → isLongestIncreasingSubsequenceLength nums result)

end LeetProofSpec

-- Equivalence theorems

theorem precondition_equiv (nums : List Int):
  VerinaSpec.longestIncreasingSubsequence_precond nums ↔ LeetProofSpec.precondition nums := by
  -- Since both preconditions are defined as True, they are trivially equivalent.
  simp [VerinaSpec.longestIncreasingSubsequence_precond, LeetProofSpec.precondition]

noncomputable section AristotleLemmas

/-
A list `s` is a sublist of `l ++ [x]` if and only if `s` is a sublist of `l` or `s` is of the form `t ++ [x]` where `t` is a sublist of `l`.
-/
theorem sublist_append_singleton_iff (s : List Int) (l : List Int) (x : Int) :
  s.Sublist (l ++ [x]) ↔ s.Sublist l ∨ ∃ t, s = t ++ [x] ∧ t.Sublist l := by
    constructor <;> intro h;
    · rw [ List.sublist_append_iff ] at h ; aesop;
    · aesop

/-
The list of subsequences generated by the foldl operation (after reversing each) is exactly the set of all sublists of `nums`.
-/
theorem verina_foldl_correct (nums : List Int) :
  ∀ s, s ∈ (nums.foldl (fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]]).map List.reverse ↔ s.Sublist nums := by
    induction' nums using List.reverseRecOn with x nums ih;
    · aesop;
    · simp +zetaDelta at *;
      intro s;
      rw [ sublist_append_singleton_iff ];
      grind

/-
`List.Pairwise (· < ·) l` is equivalent to `LeetProofSpec.isStrictlyIncreasing l`.
-/
theorem strictly_increasing_equiv (l : List Int) :
  List.Pairwise (· < ·) l ↔ LeetProofSpec.isStrictlyIncreasing l := by
    apply Iff.intro;
    · intro hl i j hij hj;
      have := List.pairwise_iff_get.mp hl;
      convert this ⟨ i, by linarith ⟩ ⟨ j, by linarith ⟩ hij;
      · grind;
      · grind;
    · rw [ List.pairwise_iff_get ];
      exact fun h i j hij => by simpa using h i.val j.val hij ( by simp ) ;

end AristotleLemmas

theorem postcondition_equiv (nums : List Int) (result : Nat) (h_precond : VerinaSpec.longestIncreasingSubsequence_precond nums):
  VerinaSpec.longestIncreasingSubsequence_postcond nums result h_precond ↔ LeetProofSpec.postcondition nums result := by
  constructor <;> intro h;
  · -- By definition of `VerinaSpec.longestIncreasingSubsequence_postcond`, we know that `result` is in the list of lengths of strictly increasing subsequences of `nums` and is the maximum length.
    obtain ⟨h_increasing, h_max⟩ := h;
    -- By definition of `List.Sublist`, we know that every element in `List.filter (fun l => List.Pairwise (· < ·) l) (List.map List.reverse ((fun (init : List (List ℤ)) => List.foldl (fun (acc : List (List ℤ)) (x : ℤ) => acc ++ List.map (fun (sub : List ℤ) => x :: sub) acc) init nums) [[]]))` is a strictly increasing subsequence of `nums`.
    have h_subseq : ∀ s ∈ List.filter (fun l => List.Pairwise (· < ·) l) (List.map List.reverse ((fun (init : List (List ℤ)) => List.foldl (fun (acc : List (List ℤ)) (x : ℤ) => acc ++ List.map (fun (sub : List ℤ) => x :: sub) acc) init nums) [[]])), s.Sublist nums ∧ LeetProofSpec.isStrictlyIncreasing s := by
      intro s hs;
      have h_subseq : s.Sublist nums := by
        exact verina_foldl_correct nums s |>.1 ( List.mem_of_mem_filter hs );
      exact ⟨ h_subseq, by simpa using strictly_increasing_equiv s |>.1 <| by simpa using List.of_mem_filter hs ⟩;
    -- By definition of `List.Sublist`, we know that every element in `List.filter (fun l => List.Pairwise (· < ·) l) (List.map List.reverse ((fun (init : List (List ℤ)) => List.foldl (fun (acc : List (List ℤ)) (x : ℤ) => acc ++ List.map (fun (sub : List ℤ) => x :: sub) acc) init nums) [[]]))` is a strictly increasing subsequence of `nums`, and its length is at most `result`.
    have h_max_subseq : ∀ s ∈ List.filter (fun l => List.Pairwise (· < ·) l) (List.map List.reverse ((fun (init : List (List ℤ)) => List.foldl (fun (acc : List (List ℤ)) (x : ℤ) => acc ++ List.map (fun (sub : List ℤ) => x :: sub) acc) init nums) [[]])), s.length ≤ result := by
      simp +zetaDelta at *;
      intro s hs hs'; specialize h_max s.reverse hs; aesop;
    -- By definition of `List.Sublist`, we know that every element in `List.filter (fun l => List.Pairwise (· < ·) l) (List.map List.reverse ((fun (init : List (List ℤ)) => List.foldl (fun (acc : List (List ℤ)) (x : ℤ) => acc ++ List.map (fun (sub : List ℤ) => x :: sub) acc) init nums) [[]]))` is a strictly increasing subsequence of `nums`, and its length is exactly `result`.
    obtain ⟨s, hs⟩ : ∃ s ∈ List.filter (fun l => List.Pairwise (· < ·) l) (List.map List.reverse ((fun (init : List (List ℤ)) => List.foldl (fun (acc : List (List ℤ)) (x : ℤ) => acc ++ List.map (fun (sub : List ℤ) => x :: sub) acc) init nums) [[]])), s.length = result := by
      grind;
    refine' ⟨ _, _ ⟩;
    · aesop;
    · intro h_nonempty
      use ⟨s, h_subseq s hs.left |>.1, h_subseq s hs.left |>.2, hs.right⟩;
      intro subseq hsubseq hsubseq_inc
      have h_subseq_in_list : subseq ∈ List.map List.reverse ((fun (init : List (List ℤ)) => List.foldl (fun (acc : List (List ℤ)) (x : ℤ) => acc ++ List.map (fun (sub : List ℤ) => x :: sub) acc) init nums) [[]]) := by
        apply (verina_foldl_correct nums) subseq |>.2 hsubseq;
      convert h_max_subseq subseq _;
      convert List.mem_filter.mpr ⟨ h_subseq_in_list, _ ⟩;
      convert strictly_increasing_equiv subseq |>.2 hsubseq_inc using 1;
      by_cases h : List.Pairwise ( fun x1 x2 => x1 < x2 ) subseq <;> simp +decide [ h ];
  · cases' h with h_empty h_nonemptycond;
    by_cases h : nums = [] <;> simp_all +decide [ LeetProofSpec.isLongestIncreasingSubsequenceLength ];
    · unfold VerinaSpec.longestIncreasingSubsequence_postcond; aesop;
    · constructor;
      · -- By definition of `verina_foldl_correct`, the list of subsequences generated by the foldl operation (after reversing each) is exactly the set of all sublists of `nums`.
        have h_sublists : ∀ s, s ∈ (nums.foldl (fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]]).map List.reverse ↔ s.Sublist nums := by
          exact?;
        obtain ⟨ ⟨ subseq, hsubseq₁, hsubseq₂, rfl ⟩, hsubseq₃ ⟩ := h_nonemptycond;
        simp_all +decide [ List.contains_iff_mem ];
        exact ⟨ subseq, ⟨ hsubseq₁, by simpa using strictly_increasing_equiv subseq |>.2 hsubseq₂ ⟩, rfl ⟩;
      · -- By definition of `allSubseq`, every element in `allSubseq` is a subsequence of `nums`.
        have h_subseq : ∀ s ∈ (nums.foldl (fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]]).map List.reverse, s.Sublist nums := by
          exact?;
        have h_subseq : ∀ s ∈ (nums.foldl (fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]]).map List.reverse, List.Pairwise (· < ·) s → s.length ≤ result := by
          exact fun s hs hs' => h_nonemptycond.2 s ( h_subseq s hs ) ( by simpa using strictly_increasing_equiv s |>.1 hs' );
        grind